# Container Transformation

## Container

### 정의

**OS의 Kernel을 공유하면서, Process를 격리된 환경에서 실행하는 기술을 의미합니다.**

>  "애플리케이션을 만들고, 배포하고, 실행하기 위한 플랫폼"



### 특징

- Ephemeral(임시) 성격
- VM과 다르게 하나의 Process로써 kill이 가능
- Namespace와 같은 Process 격리 기술을 통해서 생성되어, 독자적인 Filesystem 환경 보유
- 애플리케이션과 모든 의존성을 패키징하는 표준 방법
- 어떠한 수정 없이 애플리케이션을 여러 환경으로 이동 및 실행
- Container에 있는 모든 것들은 표준화 가능
- 밀리 초 기동 시간
- Micro Service Architecture (MSA) 장려



### Virtual Machine(VM)과 차이점

1. VM은 Hypervisor와 같은 H/W Emulation을 통해 리소스를 가상화하지만, Container는 Host와 Kernel을 공유하여 OS 수준의 가상화를 제공
2. Hypervisor에서 구동되는 VM들은 각각의 다른 OS로 구성할 수 있지만, Container는 Host에 종속적이기 때문에 Host 계열에 맞는 OS만 탑재할 수 있음
3. Conatainer는 H/W Emulation이 없기 때문에, 부팅 및 실행이 빠르고 메모리를 적게 사용

![1_wOBkzBpi1Hl9Nr__Jszplg](./images/1_wOBkzBpi1Hl9Nr__Jszplg.png)



Container 방식과 기존 방식은 아파트와 주택으로 비교 가능합니다.

![1620972307737](./images/1620972307737.png)

| Container                                                    | VM / Dedi (기존 방식)                |
| ------------------------------------------------------------ | ------------------------------------ |
| 서버의 소유 -> 대여 개념으로 전환 향후 특정 Worker Node에 POD 고정 검토 | BA가 해당 시스템의 Owner (소유)|
| OS 의존성 없음                                               | 인프라에서 OS, DB, WEB, WAS 설치     |
| 표준 서비스들이 하나의 Cluster에 존재, RBAC으로 Namespace 단위로 권한 관리 | 표준 또는 단위 서비스 마다 환경 구성 |
| AP, Infra 와의 R&R 불명확하며, DevOps 담당 팀에서 플랫폼 관리 필요 | AP, Infra 와의 R&R 명확             |
| 보안 요건 복잡                                               | 보안 요건 명확                       |
| 형상 관리 서버 중앙 집중 관리                           | 형상 관리 서버 및 CI/CD 개별 구축    |


### 목적

Cluster 환경으로 진입하는 방법의 첫 시작은 Container 화가 출발이 됩니다. 개발된 산출 결과(Java 기준 JAR, WAR 등)를 Container로 전환하는 방법과 Container 된 상태에서의 기능 수행 방법에 대해 안내하는 것을 목적으로 합니다.

참고로, Container 화 이전 까지의 기능 구축 방식에 새로운 방법이 있는 것은 아니며, 기존과 동일한 방식으로 진행 가능 하며, Container 화 작업은 일정 수준 기능이 동작할 때 진행하여 반복되는 비용을 최소화 하는 것을 가이드 합니다. 



### 개요

- 2013년 3월 Docker. inc 에서 출시. 오픈 소스 Container 프로젝트

- 리눅스 애플리케이션을 묶어서 리눅스 커널에서 제공하는 컨테이너 기술로(LXC) 실행

- Official Image와 사용자 Image도 공유하여 사용 가능 (Docker Hub)



### 가상화 VS 컨테이너

![img](./images/clip_image002.png)



- 가상화

  - 물리 장비 기반에서 + Host OS + Hypervisor  + CPU/MEM 할당 + Guest OS 설치
  - 위에 다시 Library 설치 하고, Application 사용
  - 전체 하드웨어를 가상화 함. Hypervisor에 의해 Guest OS와 Host OS를 중재
  - CPU/MEM 등의 자원 할당을 하였으나, 가상 하드웨어를 만드는 과정과 직접 CPU에 명령하는 형태로 인해 성능이 좋지 못한 단점을 가짐 (전가상화 : Full Virtualization : VirtualBox, VMWare Workstation)
  - Guest OS의 커널이 수정 안 됨

- 컨테이너 (반가상화 : Paravirtualization : VMWare ESX Server, Hyper-V, Xen, Solaris xVM Server, ...)

  - Host OS의 커널에서 자원 할당하는 LXC기술(리소스-CPU/MEM/Disk/Network의 커널 레벨 격리)
  - 물리 장비 기반 + OS + Docker Engine 
  - 위에 필요한 Library 설치 하고, Application 사용
  - Guest OS 가 설치 되지 않고, 프로그램과 라이브러리만 격리
  - Guest OS 커널 수정 됨

- Docker 성능 자료

  ![img](./images/clip_image002-1548761316984.png)





## Conatainer Orchestration

### 도입 배경

Container를 사용하면 서버의 자원을 효율적으로 사용할 수 있습니다.

- if) 컨테이너가 너무 많아져서 관리와 운영이 어려워지면?
- if) 웹 서비스에서 애플리케이션을 연중 무휴로 사용하고 싶다면?
- if) 개발자들이 새로운 버전의 애플리케이션을 하루에 몇 번씩 배포하길 원한다면?

-> 컨테이너 Conatainer Orchestration 솔루션으로 해결



### 특징

- Workload 관리 : 컨테이너들의 배포, 배치, 생명 주기를 관리
- Cluster 관리 : 다중 호스트를 하나의 타깃으로 통합
- Schedule : 여러 노드들에 걸쳐 컨테이너를 분산
- 서비스 탐색 : 컨테이너가 어디에 위치해 있는지 확인하며, 여러 컨테이너에 걸쳐 클라이언트 요청을 분산
- 복제 : 노드와 컨테이너의 개수를 보장
- Health 관리 :  비정상적인 컨테이너와 노드를 관리

![1620898135445](./images/1620898135445.png)



### 솔루션 종류

![1620898301069](./images/1620898301069.png)









## MSA (Micro Service Architecture)

### 배경

시장 변화에 조기 대응하고 유연한 시스템 운영을 위하여 국내외 IT/온라인 기업들을 중심으로 MSA 도입 및 구축이 확산 중 입니다.

![1620970372313](./images/1620970372313.png)



### 정의

“작고 자율적으로 협업하는 서비스를 결합하여 하나의 응용 프로그램을 개발하는 방법론“

| 세부 정의 | 의미                                                         |
| --------- | ------------------------------------------------------------ |
| 작고      | 한 가지 일을 잘 하는데 초점을 맞춘 서비스<br />Focused on doing one thing well |
| 자율적    | 독립된 서비스 모듈은 각각 다른 프로그래밍 언어, 다른 데이터 저장 기술로 작성 가능<br />Autonomous |
| 협업      | 독립된 서비스는 HTTP, REST API와 같은 가벼운 통신 메커니즘을 사용<br />Communicate with us via those APIs |



"기존 ESB 기반의 무겁고 복잡한 서비스를 경량화하려는 움직임"



### 변화 방향

#### 아키텍처 스타일

- SOA -> MSA
- MSA 서비스 간 연관도가 높을 경우 연계가 더 빈번해 질 위험이 있음

- 따라서 MSA 서비스도 Legacy, 타 서비스, 외부 시스템과 연계하기 위해서는 ESB / EAI를 통해야 함


| SOA                | MSA            |
| ------------------ | -------------- |
| ESB 솔루션 기반    | 오픈 소스 기반 |
| 서비스 Integration | API Gateway    |
| SOAP / XML         | HTTP / JSON    |
| 중앙 집중 관리     | 분산 관리      |



#### 리소스 경량화

- VM -> Docker
- 기존 가상화 기술의 단점인 리소스 비효율 및 관리 어려움을 해소


| VM               | Docker           |
| ---------------- | ---------------- |
| 가상 OS          | 가상 컨테이너    |
| 많은 리소스 점유 | 리소스 사용 최소 |
| 시스템 관리 복잡 | 시스템 관리 쉬움 |



#### 솔루션 선택 기준

- 벤더 사 솔루션 -> 오픈 소스
- 오픈 소스 Quaility가 향상됨

- MSA Coverage S/W 다양화 (서비스에 맞는 선택)

- 여러 글로벌 대기업의 실 적용을 통한 검증




### 적용 사례

|             | 11번가                                                       | Samsung IoT Platform (S.A.M.I)                               |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 기존 문제점 | 초대형 Monolithic System, 여러 소스가 혼재되어 변경 및 테스트 어려움<br/>8년 넘게 사용해 온 낙후된 S/W Stack<br />폭증하는 트래픽을 감당하기 위한 구성 필요 | IoT 서비스가 급격히 증가하는 비즈니스 환경 특성을 고려하여 빠른 대처를 위해 MSA 플랫폼을 구성<br/>IoT는 모든 Data, 모든 Device를 수용 가능해야 함<br />여러 그룹(QA, 개발자 등) 이 복잡한 Infrastructure 걱정 없이 운영 환경에 배포하는 것을 목표 |
| 도입 방법   | Strangler Application Pattern 으로 접근<br/>새로운 app은 MSA로 개발<br />Legacy 시스템을 점진적으로 MSA로 변환<br />반복적, 점차적 MSA 변환 작업 | 고도로 확장 가능한 PaaS를 구성<br/>- 신속한 운영 환경 구성<br />- Silo에 제한 되지 않은 확장성<br />배포 Pipeline에 Infrastructure까지 수용 하고, QA도 접목하여, 개발자가 수십 건의 코드 Release를 마찰 없이 수행 |
| 시사점      | 모든 시스템을 MSA로 한번에 전환하는 Risk 대신 Legacy와 혼용 하여 사용 하는 방법 구성<br/>Legacy, MSA 간의 Communication 방법 고안 필요 | MSA로 구성 시 도메인 별로 여러 기술 Stack 사용 가능<br/>DevOps를 적용하여 Infrastructure 및 코드 품질 걱정 없이 운영 배포 수행 |
| 구성도      | 아래 이미지 참조                                             | 아래 이미지 참조                                             |
| 기술 스택   | Spring Cloud Netflix, Hystrix, Ribbon, Eureka, Zuul, Spring boot, Netflix Turbine | Marathon(Mesos), Chronos, Jenkins, Spark, Consul             |

![1620971429921](./images/1620971429921.png)

![1620971510584](./images/1620971510584.png)



> \* Strangler Application Pattern
>
> Martin Fowler가 2004년 XP 에세이 논문에서 발표한 것으로, 열대 식물 Strangler vines 에서 유래 (Strangler : 교살 vines: 덩굴), Strangler vines는 햇빛을 받기 위해 기존 나무를 타고 올라가서 자라며, 결국 기존 나무를 죽이고 살아 남는다.  새로운 서비스로 점진적으로 교체하여, Legacy 시스템을 단계적으로 Migration하는 방법



### 도입 유형

#### A Type

- Container + MSA
- 새로운 시스템을 구성하는 신규 프로젝트일 경우
- 독립적인 역할을 수행하는 작은 단위의 서비스로 분리하여 설계가 가능한 경우

![1620971739007](./images/1620971739007.png)



#### B Type

- Conatainer Only
- 서비스 특성 상 독립적인 역할을 수행하는 작은 단위로 분리가 불가능한 경우
- 시스템 노후화 되어 대개체 등을 고려하는 경우
- 시스템 특정 시점에서 Scale-out이 필요한 경우

![1620971887557](./images/1620971887557.png)



#### C Type

- Hybrid
- 기존 시스템의 새로운 기능을 추가하는데 별도의 독립적인 역할이 가능한 서비스로 분리가 가능한 경우
- Monolithic System, 여러 소스가 혼재되어 변경 및 테스트 어려움이 있는 경우
- 낙후된 S/W Stack을 가지고 있는 재구축 대상 시스템
- 폭증하는 트래픽을 감당하기 위한 새로운 구성이 필요한 시스템

![1620971936804](./images/1620971936804.png)



## 개발 및 환경의 변화

### KT IPC Container Platform

IPC 2.0 기반 위에 구성

![1620972053193](./images/1620972053193.png)



### OpenShift

- 컨테이너 기반 Agile 인프라 아키텍처
- IPC Container Platform은 Redhat의 OpenShift 상용 버전을 사용
- Kubernetes를 기반으로 하며 K8S에 비해 관리 편의 기능 추가 

![1620972117251](./images/1620972117251.png)



### KOS 변화 방향

Container 방식은 하나의 Node에 여러 업무가 혼재 가능한 구조입니다.



KOS Legacy

![1621213843985](./images/1621213843985.png)



KOS MSA

![1621213851696](./images/1621213851696.png)



### KT MSA 표준 아키텍처

![1621214249697](./images/1621214249697.png)



### 사내 Repository 정책

- Container 플랫폼은 많은 오픈 소스 라이브러리를 참조 하기 때문에 사내에 Nexus , Yum 서버 도입
- Nexus, Yum 서버는 외부 망과 연계 하여 주기적 라이브러리 현행화 -> 개발 Lead Time 단축 
- 형상 관리 서버 Git을 통해 중앙 집중 관리

![1621214293514](./images/1621214293514.png)



### 방향성

- Container 플랫폼은 환경 구축 및 로직 구현과 상관 없는 투자 시간 감소
  - CI/CD 환경 구성 / 미들웨어 설정 / 외부 서비스 연동 설정  단축
  - 아키텍처 표준화로 아키텍처링 불필요 (Helm Chart 활용)
- 개발자는 비즈니스 로직 개발에 집중

![1621214375060](./images/1621214375060.png)

- D.D.D를 통한 Monolithic Refactoring (플랫폼 단의 경우 신규 MSA 구축과  MSA 전환 Case 가 다수)
- Strangler Application Pattern을 사용한 점진적 MSA 전환 Approach
- 2 Phase Commit 지양

![1621214475989](./images/1621214475989.png)



> 도메인 주도 설계 (Domain Driven Design) : 도메인 주도 디자인이란 개발을 함에 있어 위에서 설명한 도메인이 중심이 되는 개발 방식을 말하며, 그 목적은 소프트웨어의 연관된 부분들을 연결하여 계속 해서 진화하는 새로운 모델을 만들어 나가 복잡한 어플리케이션을 만드는 것을 쉽게 해 주는 것
>
> - 어떤 단위가 마이크로 서비스가 될 수가 있는가 ?
>   - 마이크로 서비스 크기 식별
> - 서비스를 결합 할 때는 어떻게 결합할 것인가 ?
>   - REST 데이터의 Aggregation
> - 도메인 이벤트의 식별
>   - Event-Driven Architecture 도출
> - 작은 변화에 유연한 설계
>   - 동적 서비스 발견과 연동
> - Legacy 시스템의 단계적  폐기
>   - 모더나이징
> - Refactoring 전략
>   - CI/CD와 개선
>
> ![1621214718315](./images/1621214718315.png)



## 유형 별 고려 사항

### A Type

MSA 전환 고려 대상 시스템

| 대상                        | 정의                                                         | 속성                                                         |
| --------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Multi target service 시스템 | 웹, 모바일 웹, 모바일 앱, 네이티브 앱 등 여러 target을 동시에 지원해야 하는 서비스 | 예를 들면, 인증 / 조회 / 주문 / 배송 추적 등 동일한 내용을 여러 번 개발해야 하는 시스템<br />Target간 무결성 문제 |
| 사용자 증가 시스템          | 100k -> 1000k -> 1000m으로 서비스 호출 량이 증가하는 서비스  | 고전적인 아키텍처로는 설계 및 대응이 어려움                  |
| Container화 대상 시스템     | Container 도입을 고려 중인 서비스                            | MSA는 Container 환경에서 장점이 극대화 되는 서비스           |

 

|                                                        | 주요 특징 및 장점                                            | 추가 고려 사항                                               |
| ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 단일 기능의 경량화 된 서비스 구조                      | 기존의 큰 서비스를 여러 서비스로 분리하여 구성함<br />데이터/비즈니스 로직이 독립적으로 개발<br />서비스 간의 통신은 표준 인터페이스만 사용 | 서비스에 대한 기준(경계 또는 범위)은 각 시스템 특성에 따라 다를 수 있어 정하기 어려움<br />많은 논의 시간이 필요하고 다수의 이해관계자(업무 전문가/인프라 전문가/아키텍트 등)간의 협업이 필요함<br />일반적으로 도메인(업무) 단위로 나눠서 정의하고, 여러 도메인을 하나의 서비스로 섞어서 정의하지 않아야 함 |
| 서비스 단위의 개별적 솔루션/플랫폼 적용                | 서비스 별로 독립적인 솔루션/플랫폼 적용이 가능하고, 서로 다른 언어로 개발이 가능함 (Polyglot Programming)<br/>서비스에 적합한 환경 및 언어 선택이 가능하여 비용(오픈소스 사용) 및 자원 효율성이 증대될 수 있음<br />(ex, 단순 조회 용 경량 서비스 구축 시 상용 솔루션(Jeus)대신 Tomcat 사용) | 개발/운영 인력들에게 다양한 기술 스펙이 요구됨<br/>다양한 솔루션(각종 오픈 소스)이 산발적으로 적용될 경우 유지 보수 및 대체 인력 부재의 리스크 존재함<br />(多솔루션+개별 인프라)구조에 의해 Global Transaction 구현이 불가능하여, 보상 처리가 필요함 |
| 시스템 인프라                                          | 서비스 별 독립 서버(App/DB) 구축하여 타 컴포넌트(서비스)와의 의존성을 제거한 구성<br/>시스템 전체가 아닌 서비스 별 배포가 가능하여 문제 발생 시 빠른 대처와 타 컴포넌트 영향도 최소화 효과(small size, small risk)<br />필요한 서비스들에 대한 선별적 확장이 가능 | Monolithic 구성 대비 관리 서버(App/DB) 대수가 많아 관리 포인트가 증가<br/>서비스 간 통신 시 기존(메모리 내에서의 모듈 호출) 대비 Network I/O<br />(서비스 간 HTTP 통신)가 증대하여 성능 이슈 발생 가능성 존재<br />데이터 통합 수집 DB필요<br />(서비스 별 생성된 데이터 취합을 위한 환경 필요) |
| DevOps                                                 | (개발팀=운영팀)<br/>개발과 운영 조직을 하나로 묶어서 원활한 의사소통/빠른 반영/빠른 피드백이 가능하므로 기존 대비 소프트웨어   개발 사이클 속도를 높일 수 있음<br />빌드/배포 시간이 현격히 줄어들 수 있음<br />인력 구조의 효과로 인해 문제 발생에 대한 원인 파악이 빠름 | 각 팀 별 인프라 운영자 필요(OS Engineer, DBA 등)<br />(인력 부족 시 기술 인력 보유 팀으로부터 일정 기간 지원 요청의 방식 고려 필요- 오픈소스사업팀 Ticket)<br/>개발자에게도 운영자에게 필요한 다양한 스킬이 요구됨<br />Human Error로 인한 장애의 위험성 해결 필요<br />(ex. 개발자 착오에 의한 운영 환경에서의 테스트)<br />모든 개발자가 접속 가능한 운영 환경에 대한 새로운 보안 적용 필요 |
| 서비스 단위의 (Service Based or Product Based) 팀 구성 | 소프트웨어의 구조와 소프트웨어를 만드는 팀의 구조를 일치 시킴 (ConWay’s Law)<br/>One Team, One Cycle 인력 구성 (기획 / Front / Backend / Server / QA) | (기술/운영) 팀 간 레벨 차이에 따라 서비스 간 품질 격차 발생<br/>서비스 간 Argument 및 전체 아키텍처를 관리하는 조율자 Role 필요 |

 

![1621216577114](./images/1621216577114.png)

![1621217811074](./images/1621217811074.png)

![1621218030002](./images/1621218030002.png)

![1621218132525](./images/1621218132525.png)

![1621218207964](./images/1621218207964.png)



> Monolithic 아키텍처란?
> 기존의 전통적인 웹 시스템 개발 스타일로 하나의 애플리케이션 내에 모든 로직들이 통째로 들어가 있는 구조의 아키텍쳐 스타일



### B Type

Container 전환 고려 대상 시스템

| 대상                        | 정의                                                         | 속성                                                         |
| --------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 노후화 시스템               | 시스템 대개체 도입 등을 고려 중인 노후화 된 시스템           | 노후화 시스템의 컨테이너 화를 통해 가용성 및 자원 효율화     |
| 비정기적인 시스템 부하 요구 | 특정 기간(월 말, 분기 말, 특정 기념일 등)에 과도한 부하를 유발하여 신속한 시스템 확장 요구 | 시스템 부하 증가 시 신속한 자원 제공                         |
| 개발 및 테스트              | 시스템의 설계, 개발, 테스트 단계 별로 실제 운영 시스템과 유사한 구성 필요 | 개발 및 테스트에 요구되는 시스템의 신속한 구축 및 확보 및 프로젝트 종료 후 자원 반환 |
| Pilot 프로젝트              | 초기에 적은 비용으로 POC 등의 환경을 구성 하여 테스트 필요   | 사전 정의된 패턴으로 신속한 Pilot 수행 후 자원 반환          |

 

![1621218457211](./images/1621218457211.png)



### C Type

Hybrid 전환 고려 대상 시스템

| 대상                                                        | 정의                                                         | 속성                                                         |
| ----------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 복잡도가 높은 Legacy 시스템 (Strangler Application Pattern) | 복잡도 및 업무 중요도가 높은 업무를 점진적으로 MSA/Container 전환이 필요한 프로젝트<br/>좀 더 유연한 비즈니스 지원 체계가 필요한 시스템 | 새로운 Application은 독립된 API 서버로 개발<br/>업무 도메인 별로 서비스 분리<br/>독립적인 배포가 가능하도록 서비스의 분리<br/>Legacy 코드에서는 새로운 API 서버 호출<br />기존 코드와 새로운 Application은 Flag를 통해 Switchable 하게 구성 |

MSA와 Monolithic을 고려한 Hybrid 아키텍처 
: HA Proxy를 통하여 Legacy와 Container 구분

![1621218580684](./images/1621218580684.png)



## 프로젝트 지원

### 지원 체계

프로젝트 특성에 따른 Container Transformation 방안이 제공되며, 각 유형 별 상세한 지원 체계를 제공합니다. 

![1621218786553](./images/1621218786553.png)

